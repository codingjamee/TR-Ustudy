이 앱에서 데이터를 가져오기 위해서는 브라우저에서 제공하는 내장된 fetch 함수를 사용할 것입니다. 그러나 이 fetch 함수는 사용하기에 다소 복잡하거나 특별한 면이 있을 수 있습니다. 그래서 나는 소스 폴더에 새로운 util 폴더를 만들고 그 안에 http.ts 파일을 추가할 것입니다. 이 파일의 목표는 간단한 도우미 함수를 정의하는 것으로, 이 함수를 사용하여 선택한 어떤 컴포넌트에서든 데이터를 가져올 수 있습니다. 커스텀 훅을 만들 수도 있지만, 여기서는 간단하게 내보내고 기본적인 비동기 함수를 생성할 것입니다. 이 함수는 get HTTP 요청을 보내 데이터를 가져오도록 설계되어 있어서 get이라고 부를 것입니다.

나는 이 함수 안에서 promise를 다룰 때 await 키워드를 사용할 수 있도록 비동기 키워드를 추가하고 있습니다. promise를 다루어야 하기 때문입니다. 왜냐하면 내장된 fetch 함수를 사용할 것이기 때문입니다. 이 함수는 알 수 있듯이 promise를 반환합니다. promise는 배열과 유사하여 제네릭 타입이며, 약간의 차이가 있기 때문에 제네릭 타입으로 설정되어 있습니다. promise는 자체적으로 일반적인 타입이지만, 결국 어떤 값을 생성할 promise입니다. 이 관련된 타입은 response 객체입니다. response는 promise처럼 브라우저에서 제공되는 또 다른 타입입니다.

이제 fetch가 작동하려면 HTTP 요청을 보낼 URL이 필요합니다. 유연하고 재사용 가능한 도우미 함수를 만들고 싶기 때문에 URL을 매개변수로 추가하고 fetch에 인수로 사용할 수 있도록 문자열 타입으로 설정했습니다. 이제 fetch에 두 번째 인수를 추가해서 본문을 설정하거나 HTTP 메서드를 변경할 수도 있습니다. 예를 들어 포스트 요청을 보내려면 이러한 것을 추가할 수 있습니다. 그러나 여기서는 명시적으로 간단하게 유지하고 데이터를 가져오기 위해 표준 get 요청을 보낼 것입니다.

결과적으로 약속을 얻게 되어 여기서는 이 약속을 쉽게 처리하기 위해 await 키워드를 사용하고 마침내 그 응답을 얻게 됩니다. 그 응답은 response 상수에 저장될 response 객체입니다. 이는 브라우저에서 생성된 객체로, 예를 들어 요청이 성공했는지 여부를 나타내는 okay 속성이 있습니다. 정확히는 400-ish 또는 500-ish 에러 응답을 받았는지 여부입니다. 따라서 우리는 if 문에서 이를 사용하고 응답이 okay가 아닌 경우 에러를 던집니다. 왜냐하면 fetch는 예를 들어 연결이 없기 때문에 요청을 보내지 못하면 자동으로 에러를 throw할 것이지만 기본적으로 에러 응답을 받으면 에러를 throw하지 않을 것이기 때문입니다. 나는 항상 에러 응답이 포함된 경우에는 에러를 throw하도록 유틸리티 함수를 원하고 있기 때문에 에러가 발생하면 새로운 에러 객체를 throw합니다. 여기에는 데이터를 가져오는 데 실패했다는 메시지 같은 것을 추가할 수 있습니다.

만약 if 문을 통과하면, 성공적인 응답이 있었음을 알기 때문에 어떤 데이터를 얻었습니다. 이제 그 응답 객체에서 JSON 메서드를 호출하여 데이터를 추출할 수 있습니다. 최소한 JSON 형식의 데이터를 얻는 경우에는 response라고 이름을 지어야 합니다. 그래야 성공합니다. 그러면 우리는 JSON 데이터를 얻기 위해 요청을 보내는 API에 이 함수를 사용할 수 있습니다. 대부분의 React 애플리케이션에서는 이런 경우가 대부분이며 여기도 그럴 것입니다. 그러나 JSON은 promise를 반환하고 어떤 값이든 최종적으로 반환할 것이기 때문에 TypeScript는 백엔드에서 최종적으로 반환될 데이터를 알 수 없습니다. 따라서 이렇게 작성하여 기다릴 것이지만 그 타입은 이제 any입니다.

이제 우리는 Zod와 같은 서드 파티 라이브러리를 사용하여 데이터를 유효성 검사하고 유효성 검사 결과에 따라 TypeScript에서 자동으로 타입을 추론할 수 있습니다. Zod는 정말로 흥미로운 인기 있는 라이브러리이며 이를 사용하여 이를 수행할 수 있습니다. 그러나 Zod에 대한 독립적인 강의를 만들 수도 있습니다. 명확하게 말하자면 Zod는 React와 관련이 없습니다. Angular, React 또는 다른 프레임워크나 전혀 관련이 없는 TypeScript 프로젝트에서 사용할 수 있습니다. 따라서 데이터를 검토하고 구조를 확인하며 자동으로 타입을 추론하려면 Zod를 사용할 수 있습니다. 그러나 여기서는 대신 이 데이터가 내게는 알려지지 않았다는 것을 명시하기 위

하지만 여기서는 대신 as unknown를 추가하여 나에게는 알려지지 않은 데이터임을 명확히 하겠습니다. unknown은 any보다 나은 이유가 있습니다. 왜냐하면 any를 사용하면 오류없이 모든 속성에 액세스할 수 있지만, unknown을 사용하면 TypeScript가 알지 못하는 속성에 액세스하려고 하면 오류가 발생합니다. 따라서 unknown을 사용하면 더 많은 타입 안전성을 얻을 수 있습니다. 왜냐하면 그것은 어느 시점에서는 명시적으로 자신의 타입을 설정하도록 강제하기 때문입니다. 따라서 여기서는 이 unknown 데이터를 이 유틸리티 함수에서 반환할 것입니다.

이제 자동 서식 설정 단축키를 누른 후에 내 ID가 자동으로 괄호 쌍을 추가했습니다. 이것은 await get 호출 주위에 괄호 쌍을 추가하여 명확하게 했습니다. 이렇게 하면 응답을 기다린 후에 얻게 되는 결과가 raw data blog post array 타입임을 나타냅니다. 그리고 이제 이 데이터 상수의 타입이 됩니다.

따라서 그것으로 인해 우리는 그 데이터를 이 형식을 가진 블로그 포스트 배열로 변환해야 합니다. 따라서 우리는 새로운 상수를 추가할 수 있습니다. 예를 들어 blogPosts라고 하면, 여기에는 데이터를 사용하고 이것은 원시 데이터 블로그 포스트 배열입니다.

여기에서 map 메서드를 호출할 것입니다. 물론 map 메서드는 내장 메서드로, 데이터의 각 항목에 대해 실행되어 새로운 데이터 배열을 생성합니다. 각각의 원시 포스트에 대해 실행됩니다. 결과적으로 나는 각 원시 포스트에 대해 새로운 객체를 반환하고 싶습니다. 여기서 ID를 rawPost.ID로 설정하고, 제목을 rawPost.title로 설정하고, 사용자 ID 없이 ID만 있는 형식으로 바꾸려고 합니다. 그리고 본문 대신에 문자열 형식의 text 필드를 추가하려고 합니다.

즉, 코드 일부를 추가하면 다음과 같습니다.

typescript
Copy code
const blogPosts = data.map((rawPost: any) => ({
id: rawPost.ID,
title: rawPost.title,
text: rawPost.body,
}));
이렇게 하면 각 원시 포스트를 새로운 형식으로 변환하여 blogPosts 배열에 넣을 수 있습니다.
