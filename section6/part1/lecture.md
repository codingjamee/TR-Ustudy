그럼 여기 있는 이 간격 코드의 문제는 무엇일까요?

따라서 현재 이 지점에서 우리는 여러 타이머를 만들 수 있습니다. 물론 각각 다른 지속 시간을 가지며 동시에 실행되고 동시에 종료됩니다. 그러나 물론 이 앱에서 아직 제대로 작동하지 않는 한 가지는 위에 있는 "타이머 정지" 버튼입니다. 물론 이 버튼을 누르면 모든 실행 중인 타이머를 정지하고 다시 누르면 다시 시작하는 것이 아이디어입니다. 그러려면 이미 이 전역 상태를 타이머 컨텍스트 파일에서 관리하고 있으며 해당 컨텍스트 기능을 통해 변경합니다. 거기에는 이러닝 정보가 관리되는 isRunning 상태가 있습니다. 이것을 변경하려면 리듀서 함수에서 true 또는 false로 변경해야 하며 이는 버튼이 클릭된 방식이나 버튼의 이전 상태에 따라 달라집니다.

따라서 이제 타이머 컴포넌트를 수정하여 isRunning이 false이면 타이머를 중지하고 true이면 다시 시작합니다. 따라서 첫 번째 단계로는 이 정보가 관리되는 컨텍스트에 액세스해야 합니다. 물론 이 간격 함수에서 사용하는 useTimersContext 커스텀 훅을 사용할 수 있습니다. 이 훅을 호출한 결과물에서 추출할 수 있는 isRunning 속성, 즉 true 또는 false인 부울 값을 가져올 수 있습니다. 그리고 이 부울 값은 이 효과 함수에서 사용할 수 있습니다.

시작하려면 이 효과 함수에서 이 isRunning 부울을 사용하여 간격을 설정하거나 중지하려면 간격을 지우면 됩니다. 따라서 여기에 if 문을 추가하여 isRunning이 true인지 확인하고 이 경우에는 타이머를 시작하고 간격 ID를 내 간격에 저장하려고 합니다.

그러나 isRunning이 false인 경우, 즉 true가 아닌 경우 clearInterval을 호출하여 타이머를 지우고 중지하려고 합니다. 물론 타이머는 이 if 문의 첫 번째 분기에서 스코프가 지정되므로 여기에서 사용할 수 없으므로 오류가 발생합니다. 그리고 따라서 여기에서 실제로는 interval current에 참조하고 타이머가 실행되지 않는지 그리고 interval current가 falsey가 아닌지 확인하려고 합니다. 물론 이 체크를 제거할 수 있습니다. 물론 이 메인 브랜치에서 isRunning을 true로 검사하므로 else 브랜치에서는 falsey가 될 것이므로 제거할 수 있습니다. 이렇게하면 isRunning이 false이면 해당 타이머를 정리하지만 아직이 코드는 완료되지 않았습니다. 그리고 여기에서도 종속성 배열에 대한 경고가 나타납니다. 왜냐하면 앞서 언급했듯이 종속성이 변경될 때마다 React에 의해 효과 함수가 다시 실행될 것이라고 설명했기 때문입니다. 여기에 종속성이 없으면 변경될 수 있는 것이 없으므로 이 함수는 다시 실행되지 않습니다. 따라서 지금 해야 할 일은 종속성으로 isRunning을 추가하는 것이며 isRunning이 변경되면 실행되어야 하는 효과 함수를 다시 실행하도록해야 합니다. 따라서 효과에서 이 함수를 다시 실행하려면 isRunning을 종속성으로 추가해야 합니다. 따라서 효과가 필요에 따라 다시 실행될 필요가 있으면 이 종속성이 필요하며 이 종속성을 통해 실행되어야 합니다. 이제 여기서 또 다른 문제는 타이머가 if 브랜치 내에서 생성되었으므로 여기서는 정리 함수에서 사용할 수 없다는 것입니다. 이를 해결하기 위해 효과 함수 내에서 변수로 만들어 스코프를 변경하여 간격을 저장하고 해당 변수에 number 형식을 지정해야 합니다. 따라서 타이머는 number 형식이어야 합니다. 따라서 여기에 간격의 반환 값을 저장하고 여기에서 사용할 수 있습니다. 그리고 이러한 변경 사항을 적용한 후에는 이제 타이머를 정지하고 다시 시작할 수 있어야 합니다. 따라서 여기서 다시로드하고 여기에 몇 개의 타이머를 추가하면 실행 중이 될 것입니다. 타이머를 정지하려면 정지 버튼을 누르면 모든 타이머가 정지됩니다. 시작 버튼을 다시 누르면 다시 시작됩니다. 그리고 정지된 상태에서 새 타이머를 추가하면 시작 타이머를 누를 때까지 시작되지 않습니다. 이것이 바로 원래의 동작 방식입니다.
